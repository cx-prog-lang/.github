# Notes (01.02.2026)

Developing C+ is more of a design problem than a technical problem (like in any other programming languages). The original plan was to separate the language part into two (i.e., sugar and salt parts), but the separation is not necessarily clear on the feature boundary. For example, consider a feature to support an automatic default value for struct or union types. I looked into this, and there was nothing remotely related to the automatic initialization of structs or unions in the GCC attributes. If it cannot be mimicked with any standard C features and GCC attributes, there are not many other options available but resorting to the salt part; to implement it with a custom pass (presumably an LLVM IR pass). But this feature still needs a bit of a sugar part too unless the syntax for automatic default values is perfectly legal in standard C, which will make problems because it means this feature will invalidate some part of legitimate C code, no matter how unlikely it is to be in use. Like this example, some (maybe most) features cannot be implemented solely in one part.

But, let's step back and think about it. What do we want to achieve with C+? When I first conceived C+, the initial rough idea was "something between C (baseline) and C++ (a full-blown different language)." Now, it sounds self-evident, but what does it exactly mean? If C+ claims to be another language ultimately, it's nothing more than C++, probably a lot watered-down version of it. On the other hand, if C+ entirely "dissolves" into the standard C (as in, if it's entirely implementable in the sugar part), well, actually it's not viable, and I just gave you an example above (struct default value). So technically speaking, if C+ ever wants to "add" something to C, it may not be implementable in the sugar part. But if it heavily depends on the salt part, it might as well be another language, and it's exactly when it loses every value. Where is the middle spot that it's not entirely another language, but adding some useful features to C?

I think it's important to set up a set of axioms (constraints? requirements? invariants?) that C+ must satisfy so that any design decisions can be based off them. First, by _not_ being another language, any legacy C code should "free-pass" the C+ build pipeline without any specifications or annotations. It's called _backward compatibility_ if C+ is a new version of C, if you will. Second, by being an addition to the C language, the additional features should blend into its design philosophy (=it shouldn't look or feel awkward with other standard C features and syntax). I don't know the exact design rationale of C (if it ever exists), but there are some materials about it, and I can make use of my own understandings of the C language (and why it's like that). [Relevant Link](https://www.cs.princeton.edu/courses/archive/fall16/cos217/lectures/04_DesignOfC1.pdf). Basically, the language should lean toward to the minimality (mostly for portability, I believe), free from platform dependencies, and minimum amount of hidden, _under-the-hood_ operations that are done at the language level. I think the last details hinges on the fact that it was aimed to be a system language, where some under-the-hood operations may incur unexpected results from the programmer's point of view from their own programs.

All in all, I think it's fair to say that the C+'s goal should be **an unofficial ~~or bootleg~~ version of the C language**, like _Cxx_ for the year 20xx, the year that can never happen. If we assume that, the compatibility should be supported to the level of a backward compatibility, and any additional features should blend in the design philosophy of the legacy C language.

So, not we have a direction. I think I might develop C+ as a collection of additional features that adds to the recent-most C language, and adds "what it does," "how (backward) compatible it is," and "which design princile of C it keeps" (the "design princicle" would be a lot speculative based on my own experience and impression).
